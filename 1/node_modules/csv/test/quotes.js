// Generated by CoffeeScript 1.4.0

/*
Test CSV - Copyright David Worms <open@adaltas.com> (BSD Licensed)
*/


(function() {
  var csv, fs, should;

  require('coffee-script');

  fs = require('fs');

  should = require('should');

  csv = process.env.CSV_COV ? require('../lib-cov/csv') : require('../src/csv');

  describe('quotes', function() {
    it('Test regular quotes', function(next) {
      return csv().from.path("" + __dirname + "/quotes/regular.in").to.path("" + __dirname + "/quotes/regular.tmp").on('close', function() {
        var expect, result;
        expect = fs.readFileSync("" + __dirname + "/quotes/regular.out");
        result = fs.readFileSync("" + __dirname + "/quotes/regular.tmp");
        result.should.eql(expect);
        return fs.unlink("" + __dirname + "/quotes/regular.tmp", next);
      });
    });
    it('should read quoted values containing delimiters and write around quote only the value containing delimiters', function(next) {
      return csv().from.path("" + __dirname + "/quotes/delimiter.in").to.path("" + __dirname + "/quotes/delimiter.tmp").on('close', function() {
        var expect, result;
        expect = fs.readFileSync("" + __dirname + "/quotes/delimiter.out");
        result = fs.readFileSync("" + __dirname + "/quotes/delimiter.tmp");
        result.should.eql(expect);
        return fs.unlink("" + __dirname + "/quotes/delimiter.tmp", next);
      });
    });
    it('Test quotes inside field', function(next) {
      return csv().from.path("" + __dirname + "/quotes/in_field.in").to.path("" + __dirname + "/quotes/in_field.tmp").on('close', function() {
        var expect, result;
        expect = fs.readFileSync("" + __dirname + "/quotes/in_field.out");
        result = fs.readFileSync("" + __dirname + "/quotes/in_field.tmp");
        result.should.eql(expect);
        return fs.unlink("" + __dirname + "/quotes/in_field.tmp", next);
      });
    });
    it('Test empty value', function(next) {
      return csv().from.path("" + __dirname + "/quotes/empty_value.in", {
        quote: '"',
        escape: '"'
      }).to.path("" + __dirname + "/quotes/empty_value.tmp").on('close', function() {
        var expect, result;
        expect = fs.readFileSync("" + __dirname + "/quotes/empty_value.out");
        result = fs.readFileSync("" + __dirname + "/quotes/empty_value.tmp");
        result.should.eql(expect);
        return fs.unlink("" + __dirname + "/quotes/empty_value.tmp", next);
      });
    });
    it('should read values with quotes, escaped as double quotes, and write empty values as not quoted', function(next) {
      return csv().from.path("" + __dirname + "/quotes/contains_quotes.in", {
        quote: '"',
        escape: '"'
      }).to.path("" + __dirname + "/quotes/contains_quotes.tmp").on('record', function(record, index) {
        record.length.should.eql(5);
        if (index === 0) {
          record[1].should.eql('"');
          return record[4].should.eql('"ok"');
        }
      }).on('close', function() {
        var expect, result;
        expect = fs.readFileSync("" + __dirname + "/quotes/contains_quotes.out");
        result = fs.readFileSync("" + __dirname + "/quotes/contains_quotes.tmp");
        result.should.eql(expect);
        return fs.unlink("" + __dirname + "/quotes/contains_quotes.tmp", next);
      });
    });
    it('should accept line breaks inside quotes', function(next) {
      return csv().from.path("" + __dirname + "/quotes/linebreak.in", {
        quote: '"',
        escape: '"'
      }).to.path("" + __dirname + "/quotes/linebreak.tmp").on('record', function(record, index) {
        return record.length.should.eql(5);
      }).on('close', function() {
        var expect, result;
        expect = fs.readFileSync("" + __dirname + "/quotes/linebreak.out");
        result = fs.readFileSync("" + __dirname + "/quotes/linebreak.tmp");
        result.should.eql(expect);
        return fs.unlink("" + __dirname + "/quotes/linebreak.tmp", next);
      });
    });
    it('Test unclosed quote', function(next) {
      return csv().from.path("" + __dirname + "/quotes/unclosed.in", {
        quote: '"',
        escape: '"'
      }).to.path("" + __dirname + "/quotes/unclosed.tmp").on('close', function() {
        return false.should.be.ok;
      }).on('error', function(e) {
        e.message.should.eql('Quoted field not terminated at line 1');
        return fs.unlink("" + __dirname + "/quotes/unclosed.tmp", next);
      });
    });
    it('Test invalid quotes', function(next) {
      return csv().from.path("" + __dirname + "/quotes/invalid.in", {
        quote: '"',
        escape: '"',
        delimiter: "\t"
      }).to.path("" + __dirname + "/quotes/invalid.tmp").on('close', function() {
        return false.should.be.ok;
      }).on('error', function(e) {
        e.message.should.eql('Invalid closing quote at line 1; found " " instead of delimiter "\\t"');
        return fs.unlink("" + __dirname + "/quotes/invalid.tmp", next);
      });
    });
    it('Test invalid quotes from string', function(next) {
      return csv().from.string('"",1974,8.8392926E7,""t,""', {
        quote: '"',
        escape: '"'
      }).to.path("" + __dirname + "/quotes/invalidstring.tmp").on('close', function() {
        return false.should.be.ok;
      }).on('error', function(e) {
        e.message.should.match(/Invalid closing quote/);
        return fs.unlink("" + __dirname + "/quotes/invalidstring.tmp", next);
      });
    });
    return it('should quotes all fields', function(next) {
      return csv().from.path("" + __dirname + "/quotes/quoted.in").to.path("" + __dirname + "/quotes/quoted.tmp", {
        quoted: true
      }).on('close', function() {
        var expect, result;
        expect = fs.readFileSync("" + __dirname + "/quotes/quoted.out");
        result = fs.readFileSync("" + __dirname + "/quotes/quoted.tmp");
        result.should.eql(expect);
        return fs.unlink("" + __dirname + "/quotes/quoted.tmp", next);
      }).on('error', function(e) {
        return false.should.be.ok;
      });
    });
  });

}).call(this);
